# [1] 가변성을 제한하
```text
Kotlin은 모듈로 프로그램을 설계한다.
클래스, 객체, 함수, 타입, 별칭(alias), Top-Level 등 다양한 요소로 구성된다.

이 것들은 상태(state)를 가질 수 있다.
var를 사용하거나 mutable객체를 선언하면 상태를 가지고 수정할 수 있다.
```
- State를 갖는 것은 위험성을 가진다.
  - State 끼리의 관계를 이해해야 한다.
  - 코드 수정시, 예상치못한 Error가 발생 할 수 있다.
  - Multi Thread 프로그램 일때는 적절한 동기화방법이 필요하다.
  - Test를 수행하기 어렵다.
- **가변성을 최대한 제한해야 한다.**

## Kotlin에서 가변성을 제한하는 방법
- 아래와 같은 방법으로 가변성 제한이 가능하다.
  - val 키워드
  - Immutable Collection
  - DataClass Copy

### val
- 읽기전용 키워드를 나타낸다.
- Immutable을 보장하는 것은 아니다.
  - val 참조변수가 mutable Collection을 갖고있다면 mutable 하다.
```kotlin

val a = 1
a = "hello" // val 키워드로 인한 변경 불가

/**
 * val키워드지만, 갖고있는 값이 mutable Collection
 * myList라는 변수에, 새로운 할당이 불가능 한 것이다.
 */
val myList = mutableListOf<Int>() 
myList.add(1)
myList.add(2)

```

## getter & delegate
- getter()와 delegate를 통해서도, 읽기전용을 제공할 수 있다.
  - getter()는 접근시 매번 계산한다.
    - custom getter는 get()을 할 때마다 매번 값이 달라지기 때문에 타입추론이 불가능해진다
  - delegate는 최초 초기화 이후 계속 그 값을 리턴한다.
```kotlin
val name: String? = "Marton"
val surname: String = "Braun"

val fullName: String?
    get() = name?.let { "$it $surname" }

val fullName2: String? = name?.let { "$it $surname" }

fun main(){
    if(fullName != null){
        println(fullName.length) //오류
    }
    
    if (fullName2 != null){
        println(fullName2.length) // Marton Braun
    }
}
```

## Mutable Collection과 Immutable Collection의 분리
- Kotlin은 Collection에서도 가변성을 제한한다.
- Collection: Immutable
  - 값을 변경못하게 아예 막은 것이 아니다.
  - Interface에서 변경 가능 Method를 제공해주지 않기 떄문에, 변경 할 수 없는 것이다.
  - Mutable한 Collection을 외부에 Immutable하게 보여줌으로써 얻은 안정성이다.
- MutableCollection: Mutable
  - Collection에 값 추가 / 삭제등의 연산이 가능하다.

### 하지 말 것: Collection DownCasting
```kotlin
val list = listOf(1,2,3)

if(list is MutableList){
    list.add(4)
}
```
- JVM 구현에 따라 다르다
- List Interface를 구현하였다면 정상적으로 동작한다.
- Arrays.ArrayList는 연산을 구현하지 않았기 떄문에 Exception이 발생한다.