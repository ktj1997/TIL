## 마이크로 서비스 설계의 목적
1. 기능적으로 응집성 높은 서비스의 구성
2. 각 마이크로 서비스간의 의존성 최소화

## 전략적 설계
- 컨텍스트를 나누는 단계
- 도메인 모델은 각 업무에 특화된, "유비쿼터스"언어로 정의한다.
***
### 도메인과 서브도메인
- 도메인은 비즈니스 맥락에서, 통용되는 관계 및 개념을 정의한 모형이다.
- DDD 에서는 중요도에 따라 도메인과 그 하위 도메인들을 정의한다.
- 복잡한 도메인을 논리적인 하위 도메인으로 분리한다.
  - 핵심 서브도메인
    - 경쟁자와 차별점을 둘 수 있는 핵심
    - 가장 큰 투자가 필요한 영역
  - 지원 서브도메인
    - 핵심 서브도메인 개발에 있어 꼭 필요한 영역
  - 일반 서브도메인
    - 전체 비즈니스 개발에 있어서는 필요하지만 대체 가능한 영역
***

### 유비쿼터스 언어
- 전통적인 프로젝트에서 개발자, 기획자, 프로젝트 이해관계자들 끼리 언어가 혼용되는 경우가 잦았다.
- 유비쿼터스 언어는 이해관계자들끼리 사용되는 공통의 언어로, 용어에 따른 오해를 없애게 해준다.
- 특정 도메인의 업무개념을 표현하는 언어
- 소스코드를 구현하면서, 용어가 달라지는 것은 지양한다.
***

### 바운디드 컨텍스트
- 도메인 모델간의 경계
- 이해관계자들이 업무를 파악하는 기본 모형이 된다.
- 컨텍스트 내부의 응집성은 높고, 다른 컨텍스트와의 의존관계는 낮아야한다.

***
### 컨텍스트 매핑
- 컨텍스트간의 의존관계를 의미한다.
- 모든 컨텍스트 간의 매핑관계는 컨텍스트 맵을 통해서 나타난다.

#### 1. 공유커널 (Shared Kernel)
- 바운디드 컨텍스트 사이에서, 공통적으로 모델을 공유하는 관계
- 변경 시에 여러 곳에 영향을 미치므로, 한 팀에서 맡아 관리해아 한다.

#### 2. 소비자와 공급자 (Consumer-Supplier)
- 공급자 컨텍스트는 "Upstream"으로 정의한다.
- 소비자 컨텍스트는 "DownStream"으로 정의한다.
- 데이터의 흐름은 Upstream -> DownStream 이기 떄문에, 공급자는 소비자가 원하는 기능을 제공해야한다.

#### 3. 준수자 (Conformist)
- 소비자와 공급자의 관계와 유사하다.
- UpStream이 DownStream의 요청을 받아주지 않기 때문에, DownStream이 UpStream의 제공에 맞추는 경우를 의미한다.

#### 4. 충돌 방지 계층 (Anti-Corruption-Layer)
- DownStream이 UpStream의 데이터를 받을 때, DownStream의 고유한 모델의 순수성을 지키기 위해 사용된다.
- UpStream의 모델을 DownStream 모델로 변환하는 역할을 담당하는 계층이다.

#### 5. 공개 호스트 서비스 (Open-Host-Service)
- 컨텍스트가 자신의 서비스에 접근을 허용하기위해 만든 프로토콜 및 인터페이스를 의미한다.
- DownStream이 사용이 용이하게끔 제공해야한다.

#### 6. 발행된 언어 (Published-Language)
- UpStream이 DownStream에게 서비스를 제공 할 때 정의되는 언어이다.
- OHS와 짝을 이루어서 사용한다.
- XML,JSON 등이 있다.

## 전술적 설계

### 1. 엔티티 (Entity)
- 다른 엔티티와 구별할 수 있는 식별자를 가진다.
- Mutable 하지만, 식별자는 변하지 않는다.

### 2. 값 객체 (VO)
- Immutable 하다.
- 개념적 완전성을 가진다. (각 특성들이 함께할 때 의미가 된다.)
- 도메인 내의 어떤 대상을 측정하고 수량화하며 설명한다.
- 다른값과 동등성을 통해서 비교한다.
- 관련 특징을 모은 필수단위로 개념적 전체를 모델링한다.

## 3. 표준 타입 (Enum)
- 대상의 타입을 나타내는 서술적 객체이다.
- Entity나 Vo의 속성을 구분하는 용도로 사용한다.

## 4. 에그리거트 (Aggregate)
- 하나의 유닛으로 취급될 수 있는 Entity와 Vo들의 그룹이다.
- 1~2개의 Entity, Vo, Enum등으로 구성된다.
- 가장 상위의 Entity를 AggregateRoot로 정한다.
  - AggregateRoot를 통해서만 Entity나 Vo의 값을 변경할 수 있다.
  - Aggregate 끼리의 참조도 AggregateRoot를 통해서 이루어진다.
- 하나의 BoundedContext에 하나 혹은 여러개의 Aggregate가 존재 할 수 있다.
- 트랜잭션은 Aggregate 단위로 이루어져야 한다.
  - Aggregate 사이의 트랜잭션 일관성은 Event를 사용해서 유지한다.

## 5. 도메인 서비스 (DomainService)
- 도메인 비즈니스 로직이 특정 Entity나 Vo에 속하지 않을 때, 만들어진다.
- 상태를 관리하지않고, 행위만 존재한다.
- 상태는 본인이 가지고있지 않고, Domain이나 Vo에 전달한다.

## 6. 도메인 이벤트 (Domain Event)
- 서비스간 정합성을 보장하기 위해서 Aggregate의 주요 상태값을 담을 수 있도록 모델링한다.
- 다른 서비스에 정보를 전달되는 역할을 한다.