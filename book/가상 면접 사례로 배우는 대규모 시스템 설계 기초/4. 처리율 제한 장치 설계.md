# 처리율 제한 장치 설계

## 처리율 제한 장치(RateLimiter)
- 클라이언트, 서비스가 보내는 트래픽을 제한하기 위한 장치
- 임계치(Threshold)를 넘어가면 모든 호출처리를 중단(Block)
- HTTP 429 (Too Many Request)를 응답한다.

### 처리율 제한 장치의 장점
1. DOS공격을 방지 할 수 있다.
2. 비용절감 - API CALL 횟수를 줄임으로, 서버 개수를 조절 가능하다.
3. 서버 과부하를 막는다.

### 처리율 제한 장치를 어디에 둘 것인가?
1. 클라이언트 (x)
    - 안정적인 구현이 불가능하다.
    - 클라이언트의 요청은 쉽게 위변조가 가능하다.
2. 서버 (디스크(X),메모리(O))
    1. API 서버
    2. 미들웨어 (API 서버 앞)


## 처리율 제한 알고리즘

### 1. 토큰 버킷 (Token Bucket)
- 주기적으로 Bucket에 Token이 공급된다.
- 각 Request마다 Token이 하나씩 소비된다.
- 충분한 Tokne이 없을 경우, Reqeust는 버려진다.
- 통상적으로 API 엔드포인트마다 별도의 Bucket을 둔다.

#### 장점
- 구현이 쉽다.
- 메모리 사용측면에서 효율적이다.
- 짧은시간에 집중되는 요청에대한 처리가 가능하다.

#### 단점
- Bucket의 크기와, Token공급률 값을 적절하게 튜닝하는 것이 어렵다.

### 2. 누출 버킷 (Leaky bucket)
- FIFO Queue로 구현한다.
- Queue에 빈자리가 있으면 Request를 추가한다.
- Queue가 다 차있다면, Request를 버린다.
- 지정된 시간마다 Queue에서 Request를 꺼내어 처리한다.

#### 장점
1. 큐의 크기가 고정되어있어, 메모리 사용측면에서 효율적이다.
2. 고정된 처리율을 갖고있기 때문에, 안정적인 출력이 필요한 경우에 적합하다.

#### 단점
1. 단시간에 많은 요청이 몰리는 경우, Queue에 오래된 Request들이 담겨있고,   
   최신 Request들이 버려진다.
2. Bucket 크기와, 처리율 값을 적절하게 튜닝하는 것이 어렵다.


### 3. 고정 윈도우 카운터 (Fixed Window Counter)
- TimeLine을 고정된 간격의 Window로 나누고, Window마다 Counter를 붙인다.
- Request가 들어올 때마다, Counter가 1씩 증가한다.
- Counter 값이 임계치(Threshold)에 도달하면, 새 Window가 열리기 전까지 Request는 버려진다.

#### 장점
1. 이해하기 쉽다.
2. 메모리 효율이 좋다.
3. Window가 닫히는 시점에, Counter를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기에 적합하다.

#### 단점
1. Window 경계부근에 많은 트래픽이 몰리는 경우, 기대했던 것보다 많은 트래픽을 처리하게 된다.

### 4. 이동 윈도우 로그 (Sliding Window log)
- 고정 윈도우 카운터의 **경계값에 트래픽이 몰리면 기대되는 성능을 발휘못하는 문제** 를 해결 하기 위해 만들어졌다.
- Request의 Timestamp를 추적한다.
- Timestamp의 데이터는 Redist의 SortedSet같은 캐시에 저장한다.
- 새로운 Request가 들어오면, 현재 Window 시작시점보다 오래된 만료된 Timestamp를 제거한다.
- 새로운 Request가 Window의 기준이되어, 임계치를 추적하는 것이다.

#### 장점
1. 정교하다.

#### 단점
1. 다량의 메모리를 사용한다. (거부된 요청의 Timestamp도 보관하기 때문)


## 분산환경에서의 처리율 제한장치의 구현의 문제점

### 1. 경쟁조건 (Race Condition)
1. 락(Lock)
    - 시스템의 성능을 떨어뜨린다.
2. LuaScript(루아스크립트)
3. Redis SortedSet

### 2. 동기화 (Synchronization)
1. 고정 세션(StickySession) : 클라이언트가 항상 같은 처리율 제한 장치에 요청을 보내는 것
    - 유연하지않으며, 확장성 측면에서 좋지 않다.
2. Redis같은 중앙집중화 저장소 사용

## 처리율 제한을 회피하는 방법
1. 클라이언트 캐시를 사용하여 API 호출 횟수를 줄인다.
2. Retry를 구현하는 경우, 충분한 백오프(back-off) 시간을 둔다.