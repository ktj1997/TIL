# CQRS

- 복잡한 도메인에 필요하다.
    - 단인Model일 경우, 조회기능의 로딩 속도 향상을 위해 Model이 복잡해진다.
    - 복잡한 도메인일 수록, 변경과 상태조회의 차이로 인해 Model이 불필요하게 복잡해진다.
- 단일 Model 사용시 복잡도를 줄이기 위한 방법
- 단일 Model을 상태정보 조회와, 수정을 담당하는 Model로 분리 하는 것.
- CQRS 적용 시, 각 Model에 맞는 구현 기술을 선택 할 수 있다.
    - 서로 다른 DB를 사용 할 수 도 있다.
        - 이기종간 데이터 동기화는 이벤트 기반으로 구현 가능하다.
    - QueryModel - MyBatis, QueryDSL ...
    - CommandModel - JPA ...

## 웹과 CQRS

- 대부분의 Application은 조회요청이 훨씬 많다.
- CQRS는 결국 캐시와 유사한 기능을 한다.
    - 조회화면에 적합한 데이터 형태를 빠르게 가져오는 것이기 때문이다.

## CQRS의 장단점

### 1. 장점

- Command Model 구현 시, Domain자체에만 집중 할 수 있다.
    - Query성능을 위한 추가의 로직이 필요없기 때문이다.
- QueryModel 구현으로 인해, 조회성능을 향상 시킬 수 있다.
    - 조회 단위로 기술을 적용 할 수 있다. (조회 전용 저장소 OR 캐시)

### 2. 단점

- 구현할 코드의 양이 많아진다.
- 더 많은 구현기술을 필요로한다.
- 복잡한 도메인이 아니라면 오히려 유지보수 비용이 높아진다.

# EventSourcing
- 데이터를 저장하는 방법론이다. 
- EventSourcing에서 DomainModel은 이벤트의 순차적인 실행의 결과물이다.
- 발생한 일련의 Event를 저장하고, 그 후 상태변화를 발생시키는 방식이다.
- 전통적인 최종결과값을 저장하는 방식이 아닌, **모든 이벤트 발생현황**을 저장
- Event 위주로 비즈니스 로직을 구현하고, Aggregate를 일련의 이벤트를 통해서 저장
- 조회성능을 높이기 위한 CQRS 적용은 필수이다.

## 실 사용 예시
- 버전 관리 시스템

## 사용하는 이유

- MSA 에서는 각 서비스마다 각자의 데이터를 가지게 되므로, 데이터 정합성 보장이 힘듬
    - 각 데이터가 바로 데이터를 조작 하지 못하게 제한해야함
    - Event Consumer가 해당 Event를 DB에 들어온 순서대로 적재하고, 필요 데이터를 변경
- 클라우드로 구동되는 Message 중심 분산시스템에 적합
- 언제든이 Event를 재실행(Replay)해 상태를 다시 구현할 수 있다.
- 데이터 저장을 위한 여러 Transaction의 경쟁은 성능 저하를 유발한다.

## 진행과정
1. DomainModel 이 Command(CUD) 명령을 검증한다.
2. Event를 발생시킨다.
3. Event 저장소에 저장시킨다.
4. EventHandler가 Event 저장소에 저장된 Event를 재현하여 상태를 수정한다.

## 스냅샷
- Event가 많이 쌓였을 때, 항상 초기버전부터 이벤트를 Replay하는 것은 성능상으로 좋지않다.
- State에 대한 SnapShot을 저장함으로, 성능저하를 막을 수 있다.
- SnapShot 저장소는 따로 구성한다.
  - 주로 성능이 좋은 In-Memory DB를 사용한다. 