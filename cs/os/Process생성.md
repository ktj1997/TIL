# Process 생성

## [1] fork()
- 현재 실행중인 Process를 복제하여, 새로운 Process를 만들어내는 SystemCall
- 새로 생성된 Process는 자식 Process (Child Process)라고 하며, 부모(Parent) Process의 Memory를 그대로 복사하여 실행
- 자식 Process는 부모Process와 완전히 동일한 코드와 데이터를 가진다.
  - 별개의 Process로 동작한다.
  - Memory는 복사하지만, 실제로는 다른 실행 흐름을 갖는다.
- 부모 Process는 원래대로 작업을 수행한다.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    // -1 : 에러  |  0 : 자식  |  (양수) : 부모
    pid_t pid = fork(); // fork 호출

    if (pid > 0) {
        printf("부모 프로세스: PID=%d, 자식 PID=%d\n", getpid(), pid);
    } else if (pid == 0) {
        printf("자식 프로세스: PID=%d, 부모 PID=%d\n", getpid(), getppid());
    } else {
        printf("fork 실패!\n");
    }
    return 0;
    
부모 프로세스: PID=1234, 자식 PID=5678
}
```

### CopyOnWrite
- fork()시, 자식 Process가 Data를 모두 복사하면 Memory사용량이 급격하게 증가하므로, 그에따라 최적화하는 방법이다.
- 실제로 Data가 변경될 때만 Memory를 복사하는 기법이다.
- 동작 방식
  1. fork() 실행 시, 부모와 자식 프로세스는 같은 메모리 공간을 공유
  2. 공유된 메모리는 읽기(Read) 작업에서는 그대로 사용
  3. 그러나 어떤 프로세스가 데이터를 수정하려고 하면 해당 페이지(메모리 블록)를 복사(Copy)하여 독립적인 공간에 저장
  4. 변경된 페이지만 새로운 메모리에 할당되므로 전체 메모리를 복사하는 것보다 훨씬 효율적



## [2] exec()
- 현재 실행 중인 프로세스를 완전히 새로운 프로그램으로 대체하는 시스템 호출.
- exec을 호출하면 기존의 코드와 데이터는 제거되고, 새로운 프로그램이 실행됨.
- 즉, 현재 프로세스를 유지한 채로 새로운 프로그램을 실행하는 것.
  - **fork()와 다르게, Process를 새로 만들지 않으며, 기존 Process를 새로운 Process로 덮어쓰기만 한다.
- 현재 실행중이던 Process는 종료된다.

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    char *cmd = read_command();
    int pid;
    
    if ( (pid=fork()) == 0 ) { // 자식 프로세스
    	exec(cmd); // 불러운 command 실행
    }
    else { // 부모 프로세스
   		wait(pid);
    }
    
    return 0;
}a
```


| 구분         | `fork()` | `exec()` |
|-------------|---------|---------|
| **설명**    | 현재 프로세스를 복제하여 새로운 자식 프로세스를 생성 | 현재 프로세스를 새로운 프로그램으로 교체 |
| **프로세스 개수** | 부모와 자식, 두 개의 프로세스가 실행됨 | 기존 프로세스를 새로운 프로그램으로 변경 (새로운 프로세스 생성 X) |
| **메모리 공유** | 부모와 자식 프로세스는 별도의 메모리 공간을 가짐 (복사됨) | 기존 프로세스의 메모리는 제거되고 새로운 프로그램의 메모리로 대체됨 |
| **병렬 실행 여부** | 부모와 자식 프로세스가 독립적으로 실행됨 | 기존 프로세스는 완전히 덮어쓰기되므로 병렬 실행 불가 |
| **사용 목적** | 멀티프로세싱, 부모-자식 프로세스 통신, 병렬 실행 | 다른 프로그램 실행 (e.g., `ls`, `gcc` 등 실행) |
| **코드 실행 흐름** | `fork()` 이후 부모와 자식이 동시에 실행됨 | `exec()` 호출 후 기존 코드가 제거되므로 `exec()` 이후의 코드는 실행되지 않음 |
| **사용 예시** | 서버에서 클라이언트 요청을 처리하는 다중 프로세스 방식 | 쉘(Shell)이 명령어 실행할 때, 다른 프로그램을 실행할 때 |
| **대표적인 사용 패턴** | `pid_t pid = fork();` | `execl("/bin/ls", "ls", "-l", NULL);` |