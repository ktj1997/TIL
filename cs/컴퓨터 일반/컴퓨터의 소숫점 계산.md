# 컴퓨터의 소숫점 계산
- 컴퓨터는 소수 계산을 할 때 정확한 결과를 도출하지 못할 때가 많다.
- 컴퓨터는 2진수로 계산한다.
- 2진수로 나타낼 수 없는 소수가 존재하기 때문이다.

```java
public class Example
{
	public static void main(String[] args) {
		double sum=0;
		
		for(int i=0;i<100;i++)
		    sum += 0.1;
		    
		System.out.println(sum);
        /**
         * 기댓 값: 10
         * 실제 값: 9.99999999999998
         */
    }
}
```

## [1] 부동소수점 (Floating Point)
- IEEE754 표준을 따른다.
    - double, float에 사용된다.
    - 소숫점의 위치가 고정되어 있지 않다.
- 소수를 정규화 하여, 과학적 표기법으로 표현하다.
- 연산속도가 느리다. (부동 소숫점 계산은 복잡함)
- **정밀도가 떨어진다.**
  - 정확하게 표현할 수 없는 값을 근삿값으로 처리한다.
  - 0.1을 2진수로 표현할 때 무한소수가 발생한다.
  - double(32bit), float(64bit)의 크기로 인해서 정밀도 손실이 발생 할 수 있다.
- **정밀도가 떨어짐에 따라서 오차가 누적 될 수 있기 때문에 주의해야 한다.**
### 구조
```text
value = (-1)^sign × significand × 2^exponent
```
- sign: 부호
- significand: 가수 (정말도)
- exponent: 지수 (소숫점의 위치)


### [2] 고정 소수점 (Fixed Point)
- **정수를 표현하는 자리와 소수를 표현하는 자리를 구분하고, 위치를 고정시켜 계산한다.**
  - **표현할 수 있는 범위가 한정적이라는 단점이 있다.**
- 숫자를 내부적으로 정수로 저장하고, 소수점의 위치를 고정시킨다.
  - ex) 소숫점 2자리 고정
    - 1.23 -> 123
    - 1.23 + 2.34 = 123 + 234 = 357
- **정수로 변환 후 연산하며, 결과에 소숫점 위치를 적용 시킨다.**
- **정밀도가 높다.**
    - 정수로 연산하기 때문에 정확한 값을 표현할 수 있다.
- 연산속도가 빠르다.
  - 정수 연산과 차이가 없기 때문이다.