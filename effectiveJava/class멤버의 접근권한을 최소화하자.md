# Class 멤버의 접근권한을 최소화하라

잘 설계된 컴포넌트는 구현과 API를 구분한다.

내부데이터 구현을 외부컴포넌트로 부터 숨기는 것이 중요하다.

오직 API를 통해서만 다른 컴포넌트와 소통하며, 서로의 내부방식에는 전혀 개의치않는데,

이 것을 **정보은닉 혹은 캡슐화** 라고한다.

### 캡슐화의 장점

1. 시스템 개발속도를 높인다.

   여러 컴포넌트를 병렬적으로 개발 가능하기 때문이다.

2. 시스템 관리비용을 낮춘다.

   각 컴포넌트를 더 빨리 파악하여 디버깅이 가능하며, 다른 컴포넌트로 교체가 쉽다.

3. 성능최적화에 도움을준다.

   캡슐화 그자체가 성능향상에 기여하지는 않지만, 특정 컴포넌트만 최적화가 가능하기 떄문이다.

4. 소프트웨어 재사용성을 높인다.

   외부에 의존하지않고, 독자적으로 동작할 수 있는 컴포넌트라면, 함께 개발되지 않은

   환경에서도 유용하게 쓰일 가능성이 크다.

5. 큰 시스템 개발 난이도를 낮춰준다.

   시스템 전체가 완성되지 않았더라도, 개별 컴포넌트의 동작을 검증 할 수 있기 때문이다.

### 자바의 접근제어자

1. public

   모든 곳에서 접근이 가능하다.

2. protected

   이 멤버의 하위클래스에서도 접근이 가능하며, 같은 패키지에서도 접근 가능하다.

3. package-private(default)

   같은 패키지에 있을 경우 접근이 가능하다.

4. private
5. 멤버를 선언한 클래스에서만 접근이 가능하다.

### 모든 클래스와 멤버의 접근성을 가능한한 좁히자

소프트웨어가 올바르게 동작 할 수 있는 가장 낮은 접근수준을 부여해야 한다.

public API는 최소한으로 만드는 것이 좋다.

### public class의 인스턴스 필드의 접근자는 되도록 public이 아니여야한다.

인스턴스 필드가 public으로 열려있으면 객체의 불변성(Immutable)을 보장 할 수 없다.

또한, 필드가 수정 될 때, 다른 작업을 할 수 없기 때문에, 스레드 적으로도 안전하지 않다.

public static final 객체의 경우는 예외이다. (가변객체가 아닌 불변객체에만 사용하자)

하지만 배열일 경우, public static final이여도 변경이 가능하다.

```java
private static final Object[] PRIVATE_VALUES = {};

    public static final List<Object> values1() {
        return Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
    }

    public static final Object[] values2() {
        return PRIVATE_VALUES.clone();
    }
```

만약 static 필드의 배열의 선언이 필요할 경우,

불변 리스트객체를 만들어 리턴하거나, 원본객체의 clone을 리턴해주도록 하자.