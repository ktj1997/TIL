# SAGA
- 2PC와 더불어, 대표적인 분산트랜잭션 방식
- Local 트랜잭션을 수행하고, 단계가 실패했을 때, Rollback 하기 위해서 이전 단계들에 대한 **보상트랜잭션을 발행한다.**
- **원자성을 보장하지는 않지만, 최종일관성(Eventual Consistency)를 보장한다.**
- 디버깅하기 어렵고, 복잡성이 증가한다.
    - 복잡성을 줄이기 위해서는 멱등성의 개념을 챙기는 것이 좋다.

## Choregraphy
- 중앙 집중화 되어있지 않은 Saga패턴이다.
  - 독립적인 시스템에 적합하다.
- 각 Local트랜잭션은 MessageQueue와 같은 도구를 통해서 비동기적인 이벤트를 주고 받는다.

### 장점
1. 구축하기 쉬우며, 간단한 WorkFlow에 적합 (복잡하면 각 Flow를 쫒아가기 힘듬)
2. 각 Saga참여자가 책임을 분산하게 되며, **느슨한 결합(loose-coupling)을 만족하게 된다. (Event를 통해서 상호작용 하기 떄문)
3. 느슨한 결합의 효과로, 고가용성(HA)를 만족하게 된다.

### 단점
1. 정교한 Rollback 제어 (보상트랜잭션)가 필요하다.
2. Transaction 상태를 추적하기 힘들다.

## Orchestration
- 중앙 집중화 되어있는 Saga패턴이다.
- 중앙 집중화된 Controller(Orchestrator)가 존재하고, 트랜잭션을 처리하면서 각 Saga참여자에게 수행할 작업을 알려준다.
- 각 작업의 상태를 저장 및 해석하며, 보상트랜잭션을 통해서 롤백을 제어한다.

### 장점
1. 복잡한 WorkFlow에 사용하는게 적합하다.
2. Orchestrator가 Rollback제어, 트랜잭션 상태 추적등의 기능을 담당하기 떄문에, 상태 파악이 쉽다.

#### 단점
1. Orchestrator가 SPOF가 될 수 있다.
2. Orchestrator 의존성이 높아진다.
