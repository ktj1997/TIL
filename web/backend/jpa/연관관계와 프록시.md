# 프록시
**연관관계 매핑이 되어있는 객체를 모두 로딩해야 할까?**

## em.find() vs em.getReference()

1. em.find(): 데이터베이스를 통해서 실제 엔티티 객체 조회
2. em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 조회<br>
실제 사용하는 시점에 영속성컨텍스트에 요청하고 쿼리 가 날라간다.<br>
   (프록시가 진짜 엔티티를 가리키고있다.)
   
***

## 프록시의 특징
1. 프록시 객체는 처음 사용할 때 한번만 초기화 
2. 프록시객체를 통해서 실제 엔티티에 접근하는 것(교체 되는 것이 아니다.)
3. 프록시 != 원본객체(Jpa는 Id를 통해서 동일성을 보장한다.)
4. 객체가 영속상태이면, em.getRefrence()를 사용했을 때 동일한 객체가 반환된다.<br>
   (프록시가 먼저 호출되었으면 그 뒤의 호출도 프록시,  원본객체가 먼저 호출이면 그 다음 호출도 원복객체 )
    
5. 프록시가 영속화 되지 않은상태에서 원본객체에 접근하려하면 LazyInitializationException이 발생  

***

## 지연로딩(Lazy) vs 즉시로딩(Eager)
### 지연로딩<br>
- 프록시를 이용해서 가져온다. 연관객체는 실제 사용되는 시점에 조회가 된다.
  (비지니스 로직 상 연관관계가 사용될 때도있고 안될 때도 있을 때 사용한다.)
- ToString을 열어 놓고 사용한다면 Lazy의 이점을 누릴 수 없다. (연관관계가 맺어진 Entity를 Exclude하자)  
 
### 즉시로딩 <br>
- 연관관계를 Join해서 즉시 가져온다.(프록시 x)(비지니스 로직 상 함께 쓰이는 경우가 많을 때)
   
***1. 가급적 LazyLoading을 사용하자(Eager 로딩 시 예상할 수 없는 SQL발생)***<br>
***2. \*ToOne의 경우 default가 Eager && \*ToMany는 default가 Lazy***<br>
***3. EagerLoading은 JPQL에서 N+1문제를 유발한다. (물론 Lazy도 사용할 때는 발생 // fetch join)***

***

## 영속성 전이
**특정 엔티티를 영속상태로 만들 때, 연관엔티티도 함께 영속성 상태로 만들고 싶을 때 사용**<br>
ex) 부모엔티티를 저장 할 때 자식 엔티티도 함께 저장(편리함 제공)

### Cascade의 종류
1. ALL: 모두 적용
2. PERSIST: 부모를 영속화 할 때, 자식도 영속화 한다.
3. REMOVE: 부모가 삭제될 때, 자식도 삭제한다.
4. MERGE: 부모가 준영속 상태에서 MERGE를 통해서 영속상태로 변화할 때, 자식도 영속상태가 된다.
5. REFRESH: 부모를 새로고침 할 때, 연관된 자식까지 모두 새로고침 한다.
6. DETACH: 부모가 준영속 상태가 되면, 자식도 준영속 상태로 변경된다.

***하나의 부모가 자식을 모두 관리 할 때***<br>
(게시판 첨부파일 같은 것 && LifeCycle이 유사 할 때)

***
### 고아객체
***고아객체: 부모엔티티와 연관관계가 끊어진 자식 엔티티 의미***<br>
**orphanRemoval = true** (@OneToMany, @OneToOne만 사용가능)
Collection에서 빠진 자식 엔티티는 삭제된다.

Cascade와 OrphanRemoval을 사용하면 연관관계를 부모에서 관리 가능
