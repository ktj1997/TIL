# 피드 시스템

## 문제 상황
```text
타임라인 피드란, 팔로우 관계에 있는 사용자들의 게시글 피드를 최신 순으로 볼 수 있는 기능이다.
만약 팔로워 수가 매우 많다면, 어떤 식으로 설계를 해야 할까?
```

## [1] Pull 모델
- FaceBook 에서 사용하고 있는 모델
- **Read 시점에 부하를 받는 모델이다.**
- 시간복잡도가 증가한다.

#### 테이블 연관관계
```text
USER  --> Follow <-- USER 
User --> Post
```
- Follow는 User들 사이의 연관관계를 맺은 테이블이다.
- User는 N개의 Post를 갖는다.

#### 로직 (Read)
1. 조회 할 대상의 id를 통해서 Follower들을 모두 가져온다.  --> O(log(Follow))
2. Follower들의 PK를 통해서, Post의 리스트들을 가져온다.  --> O(log(Post))

**읽기시점에서의 시간복잡도는 O(log(Follow) * log(Post))가 된다.**

#### 로직 (Write)
1. Post테이블에 저장한다. --> O(log(Post))

**쓰기시점에서의 시간복잡도는 Index의 사용으로 인해, O(log(Post))가 된다.**

#### 장점
1. 구현이 간편하다.
2. 데이터 정합성 측면에서 유리하다. (별도의 가공없이 원본데이터만을 사용하기 떄문에)
3. 추가적인 DB 테이블을 필요로 하지 않기 떄문에, 공간복잡도 측면에서 유리하다.

#### 단점
1. 사용자 수가 늘어남에 따라, 확장에 한계가 있다. (팔로워 수에 제한을 걸어야 한다거나)
2. 사용자 수가 늘어남에 따라, 조회시간의 증가와 성능저하가 발생한다.

***

## [2] Push 모델
- Twitter 에서 사용하고 있는 모델
- **Write 시점에 부하를 받는 모델이다.**
- 공간복잡도가 증가한다. 

#### 테이블 연관관계
```text
USER  --> Follow <-- USER 
User --> Post
User --> Feed
```
- Follow는 User들 사이의 연관관계를 맺은 테이블이다.
- User는 N개의 Post를 갖는다.
- User는 N개의 Feed를 갖는다.

#### 로직 (Read)
1. 조회 할 대상의 id를 통해서 Feed를 가져온다. (O(log(Feed)))

**읽기시점에서의 시간복잡도는 Index의 사용으로 인해, O(log(Feed))가 된다.**

#### 로직 (Write)
1. Post를 생성한다. --> O(log(Post)) 
2. 조회 할 대상의 id를 통해서 자신을 Follow하는 User들을 가져온다. --> O(log(Follower))
3. Feed테이블에 데이터를 넣어준다. --> O(나를 Following하는 사람의 수 * log(Feed))

**쓰기시점에서의 시간복잡도는 Index의 사용으로 인해, O(log(Post)) + O(log(Follower)) + O(나를 Following하는 사람의 수 * log(Feed)) 

#### 장점
1. Read 성능이 좋아진다.
2. 데이터 정합성 측면에서 유리하다. (별도의 가공없이 원본데이터만을 사용하기 떄문에)
3. 추가적인 DB 테이블을 필요로 하지 않기 떄문에, 공간복잡도 측면에서 유리하다.

#### 단점
1. Feed의 저장이 비동기적으로 발생하기 때문에, 특정 팔로워의 경우, 갱신이 일어나지 않았을 수 있다.
2. 별도의 테이블을 구성하기 떄문에, 공간복잡도 상으로는 불리하다.