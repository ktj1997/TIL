# 4. 클래스, 객체, 인터페이스
- 기본적으로 Kotlin의 Class는 **public**, **final** 이다.
- 짧은 주생성자 문으로 거의 모든 경우를 처리한다.
- 컴파일러가 필요한 메소드를 생성해주기도 한다. (data class)


## 4.1 클래스 계층 정의

### 4.1.1 Kotlin Interface
- Java8으 Interface와 유사하다. 
  - final, open, abstract와 같은 키워드를 사용하지 않는다.
    - 모두 열려있다.     
  - 추상메소드를 정의가능하다.
  - default 메소드를 정의 가능하다.
    - default 키워드를 가질 필요는 없다.
    - Java6에 대응하여 만들어졌기 때문에 Java8의 defaultMethod를 사용하는 것이 아니다.
      - 내부적으로 일반 Interface와 구현이 들어간 Static Class의 조합으로 이루어진다.
  - 상태는 가질 수 없다.
- ':' (컬럼) 으로 implements와  extends를 모두 표현한다.
  - 인터페이스는 원하는 개수 만큼 구현 할 수 있다.
  - 상속은 하나만 가능하다.
  - override 키워드를 사용한다.
```kotlin
  interface Clickable{
    fun click()
    /**
     * defaut 키워드를 따로 붙일 필요가 없다.
     */
    fun showOff() = println ("I'm clickable!") 
  }
  interface Focusable{
    fun showOff() = println ("I'm Focusable!")
  }
  class Button : Clickable , Focusable{
    /**
     * override 키워드는 필수이다.
     */
    override fun click() = println("I'm Button")
    
    /**
     * 만약 여러개의 이름이 같은 default 메소드가 있다면? --> 구현이 강제된다.
     */
    override fun showOfF() {
      /**
       * super<부모 제네릭>.method 형태이다.
       */
      super<Clickable>.showOff()
    }
   }
```

### 4.1.2 open, final, abstract : 기본적으로 final
- Kotlin은 기본적으로 모든 Class와 Method가 final 이다.
  - 상속이 가능하면 편리하지만, SideEffect가 발생 할 수도 있기 때문이다.
  - 상속을 가능하게 하려면 **open**을 사용해야 한다.
- 기반 Class나 Interface를 오버라이딩하는 경우, 기본적으로 해당 Method는 열려있다.
  - ```kotlin
       open class RichButton : Clickable{
          fun disable() {}  // 기본적으로 final 이다.
          open fun animate() {} // open 키워드를 사용했기 때문에 상속이 가능하다.
          override fun click() {} // 상위 클래스의 메소드를 override 했기 때문에, 열려있다. (제한 하려면 final 키워드를 앞에 사용하자)
       }
    ```
- 추상클래스는 기본적으로 상속 가능하다.
  - 추상메소드는 상속 가능하지만, 비추상메소드는 상속이 불가능하다.
  - Java에서와 같이 인스턴스화는 불가능하다.
  - ```kotlin
      abstract class Animated{
        abstract fun animate() // 기본적으로 open 이다.
        fun stopAnimation(){
          /**
           * 비 추상 함수이기 때문에, 기본적으로 final 이지만, open으로 명시적으로 열 수 있다.
           */
        }
        
       
      }
    ```
### 4.1.3 접근 제어자 : 기본적으로 public 
- public, protected, internal, private 접근 제어자가 존재한다. (package 접근 제어자는 없다)
- internal 접근제어자는 모듈안에서만 볼 수 있다.
  - Java 컴파일 시점에서는 public 으로 변경된다.
- private는 최상위 수준에도 가능하다. (클래스, 함수, 프로퍼티 등)
 
|변경자|클래스 멤버|최상위 선언|
|------|------------------|-----------------|
|public|모든 곳에서 볼 수 있다.|모든 곳에서 볼 수 있다.|
|internal|같은 모듈 안에서만 볼 수 있다.|같은 모듈 안에서만 볼 수 있다.|
|protected|하위 클래스 안에서만 볼 수 있다.|(최상위 선언에 적용 될 수 없다.)|
|private  |같은 클래스 에서만 볼 수 있다.| 같은 파일 안에서만 볼 수 있다.|

### 4.1.4 내부 클래스와 중첩클래스 : default 중첩클래스
- Kotlin도 class안에 class를 정의 할 수 있다.
  - Java는 기본적으로 내부클래스 이다.
  - Kotlin은 기본적으로 중첩클래스 이다.
- Kotlin의 중첩클래스는 명시적으로 요청하지 않는 한 **자신의 외부스코프에 대한 접근 권한이 없다.**
- 외부 스코프에 대한 참조를 갖는 내부클래스로 만들고 싶으면 **inner**을 붙여 주어야 한다.

#### 내부클래스를 지양해야 하는 이유.
- 객체가 GC대상이 될 때는 참조가 사라졌을 때 이다.
- 내부 클래스는 명시적으로 외부 클래스에 대한 참조를 갖고있다. (GC를 방해한다.)
- 메모리 누수의 원인이 된다.
