# 비동기 실행

## 0. ExecutorService

- Java에서 제공하는 병렬작업 Library
    - 1.5부터 도입됐다.
    - java.util.concurrent 패키지에 존재한다.
- Thread Pool 구축에 유리하다.

### 실행

- execute()
    - 리턴 타입이 없을 때 사용한다.
  - ```java
        executorService.execute(runnableTask);
    ```
- submit()
    - Task를 인자로 넘겨준다.
      - Callable: Future<T>
      - Runnable: Future<?> (성공적인 작업이면 get()시에 null 리턴)
    - Future을 리턴 값으로 받는다.
    - ```java
        Future<String> future = executorService.submit(callableTask);
      ```
- invokeAny()
    - 인자로 Task List를 넘겨준다.
    - 리턴 값은 성공한 Task의 값 중 하나이다.
    - ```java
        String result = executorService.invokeAny(callableTasks);
      ```
- invokeAll()
    - 인자로 Task List를 넘겨준다.
    - 리턴값은 List<Future> 이다.
    - ```java
          List<Future<String>> futures = executorService.invokeAll(callableTasks);
      ```

### 인자
- Runnable: 리턴 값이 없는 Task
- Callable: 리턴 값이 있는 Task

#### FutureTask
- Executor와 Task를 분리 할 수 있다.
- Runnable과 Callable을 Wraping 한 것이다.

### 종류

#### 1. CachedThreadPool

- Thread 갯수를 고정하지 않는다.
- **Task가 종료되어도 60초간 살아있다가 그 이후에도 Task가 들어오지 않으면 삭제된다.**

```java
class Example {

  public static void main(String[] args) {
    ExecutorService executorService = Executors.newCachedThreadPool();
  }
}
```

#### 2. FixedThreadPool

- 고정된 갯수의 Thread를 가진 Thread Pool 이다.

```java
class Example {

  private static final int THREAD_POOL_SIZE = 50;

  public static void main(String[] args) {
    ExecutorService executorService = Executors.newFixedThreadPool(THREAD_POOL_SIZE);
  }
}
```

#### 3. SingleThreadExecutor

- 한개의 Thread로 작업을 처리한다.
- 여러개의 Task를 순차적으로 하나의 Thread로 실행하는 것이다.

```java
class Example {

  public static void main(String[] args) {
    ExecutorService executorService = Executors.newSingleThreadExecutor();
  }
}
```

#### 4. ScheduledThreadPoolExecutor

- ScheduledExecutorService 이다.
    - 일정 시간 지연 후에 작업을 수행
    - 일정 시간 간격으로 작업을 수행

```java
class Example {

  private static final int THREAD_POOL_SIZE = 50;

  public static void main(String[] args) {
    ScheduledExecutorService executorService = Executors.newScheduledThreadPool(THREAD_POOL_SIZE);
    executorService.schedule(() -> {
      System.out.println("Hello");
    }, 5, TimeUnit.SECONDS);
  }
}
```

## 1. Future
- java 1.5 스펙
- Thread-Safe 하다.
- get() 메소드 실행 시, Task가 종료 될 때까지 Blocking 된다.
  - TimeOut 지정으로 긴 시간 Blocking에 대해서 예방 할 수 있다.

```java
class Example {

  public static void main(String[] args) {
    ExecutorService executor
        = Executors.newSingleThreadExecutor();

    //submit은 Fucture을 리턴 값으로 가진다.
    Future<Integer> future = executor.submit(() -> {
      long start = Instant.now().toEpochMilli();
      try {
        Thread.sleep(2000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      long time = Instant.now().toEpochMilli() - start;
      log.info("Current Thread: {} || time: {}", Thread.currentThread(), time);
      return (int) (Math.random() * 50);
    });
    Integer result = future.get();
    log.info("Result:{}",result);
  }
}
```

### 완료
1. isDone()
2. isCanceled()   

**완료 처리를 지원하는 메소드가 부족하다.**
## 2. CompletableFuture
- Java 1.8 스펙
- Future Interface의 구현체이다.
  - Future와 동일하게 사용 가능하다.
  - 넘기고 get() 사용 시, Future과 동일하게 사용하는 것이다.
- Completion Logic이 추가된 것이다.
  - 다양한 로직이 추가 된다.
  - 다음 CompletableFuture로의 연결
  - 중간 연산 (가공)
  - 종결 연산
- ForkJoinPool이 내부적으로 사용된다.

### 실행
#### 1. supplyAsync
- Supplier를 인수로 받는다.


#### 2. runAsync
- Runnable을 인수로 받는다.


### 완료

#### 1. thenApply()
- 비동기 코드간의 조합이다.
- 두개의 CompletableFuture를 결합한다.
- - 뒤에 위치하는 CompletableFuture는 선행하는 CompletableFuture의 리턴 값을 사용한다.
- Map과 같다.
  - 중첩된 CompletableFuture을 갖게된다.
  - Non-Future 형식을 갖게된다.
```java
CompletableFuture<CompletableFuture<Integer>> thenApplyFuture =
    numberFuture.thenApply(number -> { 
      return calculateSquare(number)
});
```

#### 2. thenAccept()
- 파라미타로 Consumer를 받는다.
  - CompletableFuture의 리턴 값을 Consume 한다.
- Consumer는 Void를 리턴하기 때문에, 다음 연산을 넘길 수 없댜. (종결 연산)

#### 3. thenCompose()
- 비동기 코드간의 조합이다.
- 두개의 CompletableFuture를 결합한다.
- 뒤에 위치하는 CompletableFuture는 선행하는 CompletableFuture의 리턴 값을 사용한다.
- flatMap과 같다.
  - CompletableFuture을 1 Depth로 리턴한다.
```java
CompletableFuture<Integer> thenComposeFuture =
    numberFuture.thenCompose(number -> { 
      return calculateSquare(number)
});
```


#### 4. exceptionally()
- Exception 처리 로직이다.