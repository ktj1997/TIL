# Cache란?
- 시스템 성능향상을 위한 기술
- 메모리기반으로, 디스크 기반 Database보다 훨씬 빠르게 응답이 가능하다.
- 캐시의 크기와, 만료정책은 신중하게 골라야한다.
- 캐시는 In-Memory 기반이다.
  - 비싸기 떄문에 꼭 필요한 데이터만 캐싱해야한다.
  - Memory기반이기 떄문에 유실될수도 있다.

## Cache를 언제 사용해야 하는가
- Service가 지연시간을 갖을 때
- Service의 효율성 향상 
- 일관성이 그렇게 중요하지 않을 때 (캐시는 필연적으로 데이터의 최신성의 저하를 유발한다.)
- 캐시적중률이 높을 경우 (동일한 요청에 대해서 변화할 확률이 적다.)

# 1. 캐시의 종류

## 로컬캐시
- 서비스가 실행되는 서버에 동일하게 캐시를 운영하는 것이다.
### 장점
- 구현이 쉽다.
- 추가 운영 오버헤드가 없다. (해당 서비스의 메모리에 존재하기 때문이다.)
### 단점
- 분산 서버환경에서, 서버들 사이의 데이터 정합성이 맞지 않는다.
- 서비스 초기 (혹은 배포 직후)에 ColdStart가 발생한다.

## 외부캐시
- 캐싱된 데이터를 외부의 플릿 (Memcached, Redis...)에 저장하는 것을 의미한다.

### 장점
- 모든 서버에서 사용되므로, 분산 서버환경에서 서버간의 데이터 일관성을 제공할 수 있다.
- ColdStart문제가 발생하지 않는다.
- 로컬캐시보다 공간상으로 더 크기때문에, 캐시 제거의 빈도를 줄일 수 있다. (용량의 이점)

### 단점
- 관리포인트가 증가한다.
- 캐시 노드 장애를 처리하는 서비스코드가 추가로 필요하다.
- ScaleOut시에 가동중단이나, 데이터 손실이 일어나서는 안된다.

# 2. 캐싱전략

## 읽기전략

### 1. Cache-Aside

**DB와 Cache 별도**

- 읽기 작업량이 많은 Application에서 함께 사용된다.
- 어플리케이션에서 가장 일반적으로 사용되는 캐시 업데이트 전략
- Cache와의 데이터 동기화는 Application이 담당한다.

#### 동작과정

1. Application은 Cache에 데이터가 있는지 체크한다.
2. Cache Hit일 경우, Cache로부터 데이터를 읽어 Client에게 반환한다.
3. Cache Miss일 경우, DB에서 Data를 읽어온 후, Server가 데이터를 Cache에 저장하고 Client에 반환한다.

***

### 2. Read-Through
**Cache가 DB앞에 위치**

- 읽기 작업량이 많은 Application서 함께 사용된다.
- Cache와의 데이터 동기화는 라이브러리 혹은 캐시 제공자에 의해 동기화 된다.
- Cache-Aside와의 차이점은 동기화의 주체가 Application이냐 아니냐의 차이이다.

***

#### 동작과정

1. Application은 Cache에 데이터가 있는지 체크한다.
2. Cache Hit일 경우 Cache로부터 데이터를 읽어 Client에게 반환한다.
3. Cache Miss일 경우 Cache가 DB로 부터 데이터를 읽어오고, Server는 Cache를 읽어 Client에게 반환한다.
    - DB와 Cache에 저장된 데이터모델은 같을 것이다.

### Cache Warming

- 서비스 시작 시 캐싱을 미리미리 해두는 것이다.
- 서비스 초기 (Cache가 비워져있을 때)에는 CacheMiss가 빈번히 발생할 것 이다.
- 빈번한 CacheMiss는 성능의 저하를 유발한다.
- 이를 막기위해 처음부터 Cache에 필요한 Data를 넣어주는 것을 Cache Warming이라고 한다.

***

# 쓰기전략

### 3. Write-Through
**Cache가 DB앞에 위치**

- 캐시와 DB에 동기식으로 업데이트 하기 때문에, 데이터 일관성이 유지된다.
    - DB와 Cache에 저장된 데이터모델은 같을 것이다.
    - Read-Through와 궁합이 좋다.
- 대기하는 시간이 길어지기 때문에, 성능이 떨어진다.
- DataLoss가 발생하면 안되는 상황에서 사용하는 것이 좋다.

#### 동작과정

1. Cache에 데이터를 저장한다.
2. DB에도 저장한다.

***

### 4. Write-Back (Write-Behind)
**Cache에 나중에 쓰기**

- 캐시에 먼저 등록한다음 DB에는 나중에 업데이트한다.
- DataLoss가 발생할 수도 있다. (동기화 전에 Cache가 Down된다면?)
- Data가 손실되도 괜찮고, 쓰기 작업량이 많은 Application에서 적합하다.

#### 동작과정

1. Cache에 저장한다.
2. 일정 시점에 한번 DB와 Cache를 동기화 한다.`

***

### 5. Write-Around
**Cache를 거치지 않고 DB에만 쓰기**
- DB에만 쓴다.
- Cache에 Data가 로딩되는 시점은 CacheMiss가 발생했을 때 이다.
- 기록하는 Data가 자주 사용되지 않을 때 적합하다.

#### 동작과정
1. Server는 DB에 저장한다.
2. 다른 읽기 요청에서 CacheMiss라면 Cache에 저장한다. 

***

# 3. 캐시 만료 전략

## 1. LRU
- 최근에 사용되지 않은 것 (가장 오래된 것) 을 Cache에서 Evict
- DoubleLinkedList를 통해서 최신을 Head, 오래된 것을 Tail 쪽에 두어 Eviction을 실행한다.

## 2. LFU
- 최근에 가장 덜 사용된 것을 Cache에서 Evict
- Eviction이 더 세심하게 되야 하는 경우 (Cache의 사이즈가 적다거나...) LFU가 더 좋은 전략이 될 수 있다.

## 3. FIFO
- 선입 선출




